# [2020 카카오공채] 블록 이동하기

### 정답률 : 1.4%

### 문제 설명

로봇개발자 무지는 한 달 앞으로 다가온 카카오배 로봇경진대회에 출품할 로봇을 준비하고 있습니다. 준비 중인 로봇은 2 x 1 크기의 로봇으로 무지는 0과 1로 이루어진 N x N 크기의 지도에서 2 x 1 크기인 로봇을 움직여 (N, N) 위치까지 이동 할 수 있도록 프로그래밍을 하려고 합니다. 로봇이 이동하는 지도는 가장 왼쪽, 상단의 좌표를 (1, 1)로 하며 지도 내에 표시된 숫자 0은 빈칸을 1은 벽을 나타냅니다. 로봇은 벽이 있는 칸 또는 지도 밖으로는 이동할 수 없습니다. 로봇은 처음에 아래 그림과 같이 좌표 (1, 1) 위치에서 가로방향으로 놓여있는 상태로 시작하며, 앞뒤 구분없이 움직일 수 있습니다.

![](https://grepp-programmers.s3.amazonaws.com/files/production/33f5c19ba6/052d3514-5fca-4b85-82aa-0f9eaefae0a3.jpg)

로봇이 움직일 때는 현재 놓여있는 상태를 유지하면서 이동합니다. 예를 들어, 위 그림에서 오른쪽으로 한 칸 이동한다면 (1, 2), (1, 3) 두 칸을 차지하게 되며, 아래로 이동한다면 (2, 1), (2, 2) 두 칸을 차지하게 됩니다. 로봇이 차지하는 두 칸 중 어느 한 칸이라도 (N, N) 위치에 도착하면 됩니다.

로봇은 다음과 같이 조건에 따라 회전이 가능합니다.

![](https://grepp-programmers.s3.amazonaws.com/files/production/edfcdf57d3/f87055df-91e5-4f47-b99a-400c54bfdf3a.jpg)

위 그림과 같이 로봇은 90도씩 회전할 수 있습니다. 단, 로봇이 차지하는 두 칸 중, 어느 칸이든 축이 될 수 있지만, 회전하는 방향(축이 되는 칸으로부터 대각선 방향에 있는 칸)에는 벽이 없어야 합니다. 로봇이 한 칸 이동하거나 90도 회전하는 데는 걸리는 시간은 정확히 1초 입니다.

0과 1로 이루어진 지도인 board가 주어질 때, 로봇이 (N, N) 위치까지 이동하는데 필요한 최소 시간을 return 하도록 solution 함수를 완성해주세요.
- - -

### 제한 사항

* board의 한 변의 길이는 5 이상 100 이하입니다.
* board의 원소는 0 또는 1입니다.
* 로봇이 처음에 놓여 있는 칸 (1, 1), (1, 2)는 항상 0으로 주어집니다.
* 로봇이 항상 목적지에 도착할 수 있는 경우만 입력으로 주어집니다.
- - -

### 입출력 예

![](https://user-images.githubusercontent.com/44596066/71302114-ec2e5400-23ea-11ea-840f-80fe0eb078b9.png)
- - -

### 입출력 예에 대한 설명

문제에 주어진 예시와 같습니다.
로봇이 오른쪽으로 한 칸 이동 후, (1, 3) 칸을 축으로 반시계 방향으로 90도 회전합니다. 다시, 아래쪽으로 3칸 이동하면 로봇은 (4, 3), (5, 3) 두 칸을 차지하게 됩니다. 이제 (5, 3)을 축으로 시계 방향으로 90도 회전 후, 오른쪽으로 한 칸 이동하면 (N, N)에 도착합니다. 따라서 목적지에 도달하기까지 최소 7초가 걸립니다.
- - -

### 출제 의도

* BFS에 대해 알고 있고, 이를 응용해(단순 암기가 아니라) 코드를 작성할 수 있는지 파악

### 해설

BFS를 이용해 해결할 수 있지만, 코딩에 상당한 난이도를 요구했던 문제입니다. 기본적으로 간선의 비용이 1인 최단거리 문제와 동일하나, 로봇이 회전할 수 있다는 점을 신경 써야 합니다.

먼저 현재 로봇의 상태를 표현하기 위해 다음과 같이 상태를 정의해줍니다.

(r, c, d) : (r, c) 위치에서 d 방향에 있는 칸을 한 칸 더 차지하고 있음

로봇이 두 칸을 차지하고 있기 때문에 로봇이 (r, c), (r, c + 1) 위치에 놓인 경우, (r, c) 위치에서 (r, c + 1) 칸을 한 칸 더 차지하고 있음과 (r, c + 1) 위치에서 (r, c) 칸을 한 칸 더 차지하고 있음이 같은 상태라는 점을 주의해야 합니다.

현재 상태에서 로봇이 움직이는 방법은 다음과 같이 8가지입니다.

* 로봇이 상, 하, 좌, 우로 움직임(4가지)
* 로봇이 첫 번째 칸을 기준으로 시계방향, 반시계 방향으로 회전(2가지)
* 로봇이 두 번째 칸을 기준으로 시계방향, 반시계 방향으로 회전(2가지)
  로봇이 회전하는 경우 벽과 충돌하면 안 되기 때문에, 충돌 판정은 다음과 같이 할 수 있습니다.
* 로봇은 항상 수평, 또는 수직으로만 놓이기 때문에, 충돌 확인을 해야 하는 후보칸은 회전축을 기준으로 대각선 방향에 있는 칸 4개입니다.
* 충돌 확인을 해야 하는 칸은 회전하기 전에 로봇이 위치한 칸(축이 아닌 칸)까지의 맨해튼 거리와 회전한 후에 로봇이 새로 위치한 칸까지의 맨해튼 거리가 1입니다.

이를 이용해 회전 후 충돌 판정을 확인해야 되는 칸이 어디인지 찾아낼 수 있습니다. 이외에도 다양한 방법을 이용해 충돌 판정을 확인할 수 있습니다.

이제 각각의 상태에 대해 BFS 탐색을 진행하면서 가장 빠른 시간을 찾으면 됩니다.

- - -

### 참고 사항

> https://programmers.co.kr/learn/courses/30/lessons/60063
